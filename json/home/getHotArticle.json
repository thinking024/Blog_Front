{"code":100,"msg":"success","data":[{"articleId":1,"articleUserId":1,"articleTitle":"[转载]SpringMVC中使用Interceptor拦截器","articleViewCount":27,"articleCommentCount":0,"articleLikeCount":3,"articleCreateTime":1507334058000,"articleUpdateTime":1543179112000,"articleIsComment":1,"articleStatus":1,"articleOrder":1,"articleContent":"<p>SpringMVC 中的Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登陆，或者是像12306 那样子判断当前时间是否是购票时间。</p><p><br></p><p>一、定义Interceptor实现类</p><p>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor 非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。</p><p><br></p><p>（一）实现HandlerInterceptor接口</p><p>HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。</p><p><br></p><p>（1 ）preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。</p><p><br></p><p>（2 ）postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行，这和Struts2里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</p><p><br></p><p>（3 ）afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。</p><p><br></p><p>下面是一个简单的代码说明：</p><p><br></p><p>import javax.servlet.http.HttpServletRequest;</p><p>import javax.servlet.http.HttpServletResponse;</p><p>import org.springframework.web.servlet.HandlerInterceptor;</p><p>import org.springframework.web.servlet.ModelAndView;</p><p>public class SpringMVCInterceptor implements HandlerInterceptor {</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 回值为false，当preHandle的返回值为false的时候整个请求就结束了。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public boolean preHandle(HttpServletRequest request,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, Object handler) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return false;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像，&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void postHandle(HttpServletRequest request,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, Object handler,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ModelAndView modelAndView) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行，&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void afterCompletion(HttpServletRequest request,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, Object handler, Exception ex)</p><p>&nbsp; &nbsp; throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; }</p><p>}</p><p>（二）实现WebRequestInterceptor 接口</p><p>WebRequestInterceptor 中也定义了三个方法，我们也是通过这三个方法来实现拦截的。这三个方法都传递了同一个参数WebRequest ，那么这个WebRequest 是什么呢？这个WebRequest 是Spring 定义的一个接口，它里面的方法定义都基本跟HttpServletRequest 一样，在WebRequestInterceptor 中对WebRequest 进行的所有操作都将同步到HttpServletRequest 中，然后在当前请求中一直传递。</p><p><br></p><p>（1 ）preHandle(WebRequest request) 方法。该方法将在请求处理之前进行调用，也就是说会在Controller 方法调用之前被调用。这个方法跟HandlerInterceptor 中的preHandle 是不同的，主要区别在于该方法的返回值是void ，也就是没有返回值，所以我们一般主要用它来进行资源的准备工作，比如我们在使用Hibernate 的时候可以在这个方法中准备一个Hibernate 的Session 对象，然后利用WebRequest 的setAttribute(name, value, scope) 把它放到WebRequest 的属性中。这里可以说说这个setAttribute 方法的第三个参数scope ，该参数是一个Integer 类型的。在WebRequest 的父层接口RequestAttributes 中对它定义了三个常量：</p><p><br></p><p>SCOPE_REQUEST ：它的值是0 ，代表只有在request 中可以访问。</p><p><br></p><p>SCOPE_SESSION ：它的值是1 ，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。</p><p><br></p><p>SCOPE_GLOBAL_SESSION ：它的值是2 ，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session 范围内可以访问。</p><p><br></p><p>（2 ）postHandle(WebRequest request, ModelMap model) 方法。该方法将在请求处理之后，也就是在Controller 方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型ModelMap 来改变数据的展示。该方法有两个参数，WebRequest 对象是用于传递整个请求数据的，比如在preHandle 中准备的数据都可以通过WebRequest 来传递和访问；ModelMap 就是Controller 处理之后返回的Model 对象，我们可以通过改变它的属性来改变返回的Model 模型。</p><p><br></p><p>（3 ）afterCompletion(WebRequest request, Exception ex) 方法。该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。所以在该方法中可以进行资源的释放操作。而WebRequest 参数就可以把我们在preHandle 中准备的资源传递到这里进行释放。Exception 参数表示的是当前请求的异常对象，如果在Controller中抛出的异常已经被Spring 的异常处理器给处理了的话，那么这个异常对象就是是null 。</p><p><br></p><p>&nbsp;</p><p><br></p><p>下面是一个简单的代码说明：</p><p><br></p><p>import org.springframework.ui.ModelMap;</p><p>import org.springframework.web.context.request.WebRequest;</p><p>import org.springframework.web.context.request.WebRequestInterceptor;</p><p>public class AllInterceptor implements WebRequestInterceptor {</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 在请求处理之前执行，该方法主要是用于准备资源数据的，然后可以把它们当做请求属性放到WebRequest中&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void preHandle(WebRequest request) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"AllInterceptor...............................\");</p><p>&nbsp; &nbsp; &nbsp; &nbsp; request.setAttribute(\"request\", \"request\", WebRequest.SCOPE_REQUEST);//这个是放到request范围内的，所以只能在当前请求中的request中获取到&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; request.setAttribute(\"session\", \"session\", WebRequest.SCOPE_SESSION);//这个是放到session范围内的，如果环境允许的话它只能在局部的隔离的会话中访问，否则就是在普通的当前会话中可以访问&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; request.setAttribute(\"globalSession\", \"globalSession\", WebRequest.SCOPE_GLOBAL_SESSION);//如果环境允许的话，它能在全局共享的会话中访问，否则就是在普通的当前会话中访问&nbsp;&nbsp;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 该方法将在Controller执行之后，返回视图之前执行，ModelMap表示请求Controller处理之后返回的Model对象，所以可以在&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 这个方法中修改ModelMap的属性，从而达到改变返回的模型的效果。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void postHandle(WebRequest request, ModelMap map) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; for (String key:map.keySet())</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(key + \"-------------------------\");;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; map.put(\"name3\", \"value3\");</p><p>&nbsp; &nbsp; &nbsp; &nbsp; map.put(\"name1\", \"name1\");</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 该方法将在整个请求完成之后，也就是说在视图渲染之后进行调用，主要用于进行一些资源的释放&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void afterCompletion(WebRequest request, Exception exception)</p><p>&nbsp; &nbsp; throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(exception + \"-=-=--=--=-=-=-=-=-=-=-=-==-=--=-=-=-=\");</p><p>&nbsp; &nbsp; }</p><p>}</p><p><br></p><p>&nbsp;二、把定义的拦截器类加到SpringMVC的拦截体系中</p><p>1.在SpringMVC的配置文件中加上支持MVC的schema</p><p><br></p><p>xmlns:mvc=\"http://www.springframework.org/schema/mvc\"</p><p>xsi:schemaLocation=\" http://www.springframework.org/schema/mvc</p><p>&nbsp; &nbsp; http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\"</p><p>下面是我的声明示例：</p><p><br></p><p><br></p><p><br></p><p>这样在SpringMVC的配置文件中就可以使用mvc标签了，mvc标签中有一个mvc:interceptors是用于声明SpringMVC的拦截器的。</p><p><br></p><p>&nbsp;</p><p><br></p><p>（二）使用mvc:interceptors标签来声明需要加入到SpringMVC拦截器链中的拦截器</p><p><br></p><p><br></p><p>&nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp;&nbsp;</p><p><br></p><p><br></p><p>由上面的示例可以看出可以利用mvc:interceptors标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，先声明的拦截器中的preHandle方法会先执行，然而它的postHandle方法和afterCompletion方法却会后执行。</p><p><br></p><p>在mvc:interceptors标签下声明interceptor主要有两种方式：</p><p><br></p><p>（1）直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。</p><p><br></p><p>（2）使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。</p><p><br></p><p>经过上述两步之后，定义的拦截器就会发生作用对特定的请求进行拦截了。</p><p><br></p><p><br></p><p><br></p>","articleSummary":null,"articleThumbnail":"/img/thumbnail/random/img_1.jpg","user":null,"tagList":null,"categoryList":null},{"articleId":32,"articleUserId":2,"articleTitle":"Docker_入门？只要这篇就够了！（纯干货适合0基础小白）","articleViewCount":16,"articleCommentCount":10,"articleLikeCount":0,"articleCreateTime":1543179905000,"articleUpdateTime":1556228578000,"articleIsComment":1,"articleStatus":1,"articleOrder":1,"articleContent":"<p>原文地址：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=https://blog.csdn.net/S_gy_Zetrov/article/details/78161154\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/S_gy_Zetrov/article/details/78161154</a></p><h2 id=\"写在前面\">写在前面</h2><ul><li>这篇博客适合谁？<ul><li>对于Docker并不了解，只是有一点模糊的感觉，觉得Docker可以当成虚拟机用之类的</li><li>只是下载了Docker软件，对于怎么配置，怎么玩，第一步干什么，完全一无所知</li><li>本文适用于mac，PC用户不保证文章的效果，现在离开来得及</li></ul></li><li>网上Docker相关的教程都泛滥了，为啥还要写，为啥我要看你的文章<ul><li>首先欢迎你，能搜索到我的博客就是缘分</li><li>其次，确实，现在Docker相关的文章真的太多了，那我为什么还要写呢？原因有三：<ul><li>其一，文章是很多，各种1小时入门什么的，相信你已经在知乎看过很多了，我也看过，<br>因为我就是从知乎那几篇教程为起点，自己抠出来的，现在把自己的心得和经验贴出来，我觉得既是对自己负责也能服务他人。</li><li>其二，我从对Docker只有及其模糊（真的是模糊，我除了知道Docker是跟虚拟系统有关其他啥都不知道），到现在起码一<br>问一不知（对应一问三不知）的状态，大概花了8个小时。这期间全靠我从网络上搜索到的资料。现在用我的话写出来，我觉得对于跟我相同开始情况的小白用户，能省不少时间，所以我要写。</li><li>其三，因为我自己是纯靠搜索到的教程和技术文章学习的Docker，我自然是懂得干涩的语言对学习的拖慢。所以我自己写的时候，自然会考虑到这个问题。本文尽量不用技术用语，尽量使用通俗易懂的文字，为进一步拉低Docker的入门门槛作出我自己的贡献。</li></ul></li></ul></li><li>这篇文章主要是哪方面的Docker文章，纯入门？你做了哪些工作？<ul><li>很高兴你问了我这个问题。本文主要：<ul><li>首先对于Docker的概念作出我的解释，尽量通俗易懂</li><li>接着针对我用Docker的目的，从最开始的软件下载，到最后push一个自己的镜像到hub，整个过程以白话的形式描述出来，降低入门门槛，节省你的学习时间</li></ul></li><li>我做了哪些工作？这是个好问题！<ul><li>首先，我一直都很好奇Docker这个东西，但从来没有机会去使用它。但是，这学期OS课的lab，纯Linux系统编程，虽然使用双系统或者虚拟机都是纯小学生的难易程度了，也不麻烦，但我想，为什么不用Docker呢？用双系统或者虚拟机也太过小儿科！所以，我就这样接触了Docker</li><li>那么我使用Docker实现了什么？在lab中，我们需要用到的是纯终端下的gcc工具链还有vim等，那么这就是我需要的全部软件了！于是我在Docker中实现了「gcc+gdb<br>+vim」环境，并push到了hub中。</li></ul></li></ul></li><li>你这篇博客有没有抄别人的？<ul><li>额，我学习Docker时确实看了很多很多（真的是很多）文章，现在写这篇博客，除了自己的经验心得，自然还得去看那些文章。但我能保证的是，我写的都是取精华去糟粕，不然这篇文章就不必存在了你说是不是？</li><li>参考资料会在文后统一附上，谢谢！</li></ul></li></ul><p>好了，闲话说完，我们开始吧！</p><p>&nbsp;</p><h2 id=\"入门docker你要下载什么注册什么\">入门Docker，你要下载什么？注册什么？</h2><p id=\"dockerapp你肯定是要下载的\"><strong><span>+ Docker.app你肯定是要下载的！</span></strong></p><p>Docker for mac，这个你肯定要下载：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=https://www.docker.com/community-edition\" target=\"_blank\" rel=\"noopener noreferrer\">点我下载Docker for mac的社区免费版本</a></p><p>&nbsp;</p><p id=\"注册docker官方账号你需要它\"><strong><span>+ 注册Docker官方账号，你需要它！</span></strong></p><p>注册一个Docker的官方账号，有利而无害，相信我！<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=https://cloud.docker.com/swarm/sgyzetrov/dashboard/onboarding/cloud-registry\" target=\"_blank\" rel=\"noopener noreferrer\">点我注册Docker Cloud官方账号</a></p><p>Docker安装好，账号也注册后，点击桌面顶栏的Docker图标，点击sign in，登陆你的Docker账号。</p><p>&nbsp;</p><h2 id=\"注册daocloud账号获取加速服务\"><span>+ 注册DaoCloud账号，获取加速服务！</span></h2><p>不可否认，有时直接从Docker官方往本地pull镜像会十分缓慢。。。这时我们可以通过国内的Docker服务提供商免费获取加速pull镜像服务，阿里网易好像都有这种服务，我选择的是DaoCloud：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=https://account.daocloud.io/signup\" target=\"_blank\" rel=\"noopener noreferrer\">点我注册DaoCloud账号</a></p><p>注册后登陆DaoCloud，找到这个按钮：</p><p><img title=\"\" data-original=\"https://img-blog.csdn.net/20171005113053850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU19neV9aZXRyb3Y=/font/5a6L5L2T/fontsize/1400/fill/I0ZGMDAwMA==/dissolve/90/gravity/Center\" src=\"https://media.liuyanzhao.com/wp-content/themes/begin/img/blank.gif\" alt=\"docker1.png\"></p><p>接着，按照它的步骤，为自己添加Docker加速服务</p><p><img title=\"\" data-original=\"https://img-blog.csdn.net/20171005113639144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU19neV9aZXRyb3Y=/font/5a6L5L2T/fontsize/1400/fill/I0ZGMDAwMA==/dissolve/70/gravity/Center\" src=\"https://media.liuyanzhao.com/wp-content/themes/begin/img/blank.gif\" alt=\"docker2\"></p><h4></h4><p id=\"到此准备工作结束进入下一部分\"><strong><span>+ 到此准备工作结束，进入下一部分！</span></strong></p><p>&nbsp;</p><h2 id=\"要想入门docker首先你需要理解docker\">要想入门Docker，首先你需要理解Docker！</h2><p>我也不扯淡了，直接上我对Docker的理解：(Copyright ©&nbsp;<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://blog.csdn.net/s_gy_zetrov\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.csdn.net/s_gy_zetrov</a>. All Rights Reserved)</p><p>Docker，可以说是一个终端命令行的虚拟机，但更准确的说法，其实应该是一个虚拟环境。比如，你想要在PC上无缝使用Linux么？那么虚拟机并不是你唯一的出路，你还有Docker！我更愿意称Docker为一个容器，当然这只是Docker的一个狭义解释，Docker不止是一个容器。Docker包含3个重要概念：</p><ul><li>一个，是镜像（Image），镜像是静态的、可以被用户互相分享的文件。我们玩过双系统和虚拟机的人都知道，首先你需要一个.iso镜像，才能安装系统。Docker中的镜像也是这个东西，<strong><span>镜像是静态的，你不能对他操作，只能pull别人的镜像或者push自己的镜像</span></strong>。</li><li>还有一个，是容器（Container），前面说过，镜像是静态不可操作的，只能被分享和下载，那什么是能被操作的呢？就是容器里！容器可以理解为镜像的动态状态，也就是我们虚拟机中系统装好后的状态，其实这么说是不对的，容器最符合的描述应该是Linux的iso文件的<code>Live CD</code>模式，比如我们玩双系统时都进入过<code>Live CD</code>模式，不安装系统而直接进入系统，很神奇是吧，Docker的容器就是这个概念，只不过更加轻量更加迅速便捷。但是<code>Live CD</code>的害处就是你关机后作出的修改安装的软件全部gg，<strong><span>容器也是一样，一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在</span></strong>。</li><li>最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。</li></ul><p>接下来来张高大上的概念图，各位看个热闹2333</p><p><img title=\"\" data-original=\"https://img-blog.csdn.net/20171005120538429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU19neV9aZXRyb3Y=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" src=\"https://media.liuyanzhao.com/wp-content/themes/begin/img/blank.gif\" alt=\"docker3.png\"></p><h3 id=\"接下来就是实战了打开你的iterm2我是iterm2党2333打开普通terminal也行这个不影响\">接下来就是实战了！打开你的iTerm2！（我是iTerm2党2333，打开普通terminal也行，这个不影响）</h3><p>&nbsp;</p><p id=\"查看docker版本信息\"><strong><span>+ 查看Docker版本信息</span></strong></p><pre class=\"prettyprint\"><code class=\"hljs livecodeserver has-numbering\">终端输入：\r\n<strong><span>docker <span class=\"hljs-built_in\">version</span></span></strong></code></pre><p>&nbsp;</p><p>显示的我的版本信息</p><pre class=\"prettyprint\"><code class=\"hljs r has-numbering\"> ~$ docker version\r\nClient:\r\n Version:      <span class=\"hljs-number\">17.06</span><span class=\"hljs-number\">.2</span>-ce\r\n API version:  <span class=\"hljs-number\">1.30</span>\r\n Go version:   go1.8.3\r\n Git commit:   cec0b72\r\n Built:        Tue Sep  <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">20</span>:<span class=\"hljs-number\">12</span>:<span class=\"hljs-number\">06</span> <span class=\"hljs-number\">2017</span>\r\n OS/Arch:      darwin/amd64\r\n <span class=\"hljs-keyword\">...</span>\r\n //omitted by sgy(Copyright © http://blog.csdn.net/s_gy_zetrov. All Rights Reserved)\r\n <span class=\"hljs-keyword\">...</span></code></pre><p>不过我一般不需要那么多信息，所以一直用的是<code>docker -v</code>命令</p><h4></h4><p id=\"是时候pull你的第一个镜像下来的\"><strong><span>+ 是时候pull你的第一个镜像下来的！</span></strong></p><p>Docker安装好后是不会自带镜像的，你需要从仓库自己pull一个镜像下来，自己制作自己的镜像也是一个道理，你可以通过在已有的镜像基础上生成自己的镜像或者看一下这篇博客:&nbsp;<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://blog.csdn.net/shiqiangdexin/article/details/52472195\" target=\"_blank\" rel=\"noopener noreferrer\">随便百度的如何创建自己Docker镜像得到的教程</a></p><p>Docker镜像官方好像只提供Linux，这个很容易想，windows和mac是要交钱的吧大概？（否）</p><p>搜索ubuntu的Docker镜像<strong><span><code>docker search ubuntu</code></span></strong>，这个如果你想要什么centos，直接改就行，不区分写法,我的返回结果：</p><pre class=\"prettyprint\"><code class=\"hljs r has-numbering\">~$ docker search ubuntu\r\nNAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\r\nubuntu                                                 Ubuntu is a Debian-based Linux operating s...   <span class=\"hljs-number\">6636</span>                [OK]\r\ndorowu/ubuntu-desktop-lxde-vnc                         Ubuntu with openssh-server and NoVNC            <span class=\"hljs-number\">131</span>                                     [OK]\r\nrastasheep/ubuntu-sshd                                 Dockerized SSH service, built on top of of...   <span class=\"hljs-number\">105</span>                                     [OK]\r\nansible/ubuntu14.04-ansible                            Ubuntu <span class=\"hljs-number\">14.04</span> LTS with ansible                   <span class=\"hljs-number\">86</span>                                      [OK]\r\nubuntu-upstart                                         Upstart is an event-based replacement <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">...</span>   <span class=\"hljs-number\">80</span>                  [OK]\r\nneurodebian                                            NeuroDebian provides neuroscience research...   <span class=\"hljs-number\">40</span>                  [OK]\r\nubuntu-debootstrap                                     debootstrap --variant=minbase --components...   <span class=\"hljs-number\">31</span>                  [OK]\r\n<span class=\"hljs-keyword\">...</span>\r\n//omitted by sgy(Copyright © http://blog.csdn.net/s_gy_zetrov. All Rights Reserved)\r\n<span class=\"hljs-keyword\">...</span></code></pre><p>&nbsp;</p><p>拉取官方最新版的ubuntu镜像：<strong><span><code>docker pull ubuntu:latest</code></span></strong>，其中的latest是一个标签（tag），表示是当前最新版本。你应该得到的信息，类似这样的</p><pre class=\"prettyprint\"><code class=\"hljs r has-numbering\">～$ docker pull ubuntu:latest\r\nTrying to pull repository docker.io/<span class=\"hljs-keyword\">library</span>/ubuntu <span class=\"hljs-keyword\">...</span> \r\nlatest: Pulling from docker.io/<span class=\"hljs-keyword\">library</span>/ubuntu\r\naed158d74952: Pull complete \r\n773ae8273d14: Pull complete \r\nd1d487w88782: Pull complete \r\ncd3d6cd6c0cf: Pull complete \r\n8d73bu79120c: Pull complete \r\nDigest: sha256:35bc48a1ca97c3f74rhf378hj92hd82j29i4hf4hf84nf0dhnsid232de8d8\r\nStatus: Downloaded newer image <span class=\"hljs-keyword\">for</span> docker.io/ubuntu:latest</code></pre><p><strong><span>你输入的命令实际上相当于<code>docker pull registry.hub.docker.com/ubuntu:latest</code>命令，即从注册服务器<code>registry.hub.docker.com</code>中的名为<code>ubuntu</code>的仓库中下载标签为<code>latest</code>的镜像</span></strong>。</p><p>&nbsp;</p><p>由于我的lab统一要求，ubuntu需要14.04版本，所以我在hub里面搜了搜，<strong><span>找到了一个用户分享的14.04 64位纯净镜像（base image）</span></strong>，下面将他的镜像扒下来</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">~<span class=\"hljs-variable\">$ </span>docker pull chug/ubuntu14.<span class=\"hljs-number\">04</span>x64</code></pre><p>这个用户还有很多其他版本的ubuntu系统，12 13 14的32位64位都有，全是纯净镜像。</p><h4></h4><p id=\"查看你本地的镜像仓库\"><strong><span>+ 查看你本地的镜像仓库！</span></strong></p><p>把初始镜像拉下来后，就可以启动它了，不过，可以先使用<code>docker images</code>命令查看你自己的本地镜像，我随便找了个例子，你的也应该是类似这样的：</p><pre class=\"prettyprint\"><code class=\"hljs lua has-numbering\">～$ <span><strong>docker images</strong></span>\r\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\r\ndocker.<span class=\"hljs-built_in\">io</span>/ubuntu    <span class=\"hljs-number\">16.04</span>               e4415b714b62        <span class=\"hljs-number\">11</span> days ago         <span class=\"hljs-number\">128.1</span> MB\r\ndocker.<span class=\"hljs-built_in\">io</span>/ubuntu    latest              e4415b714b62        <span class=\"hljs-number\">11</span> days ago         <span class=\"hljs-number\">128.1</span> MB\r\ndocker.<span class=\"hljs-built_in\">io</span>/ubuntu    <span class=\"hljs-number\">12.04</span>               aefa163f7a7e        <span class=\"hljs-number\">11</span> days ago         <span class=\"hljs-number\">103.5</span> MB\r\ndocker.<span class=\"hljs-built_in\">io</span>/centos    latest              <span class=\"hljs-number\">0584</span>b3d2cf6d        <span class=\"hljs-number\">3</span> weeks ago         <span class=\"hljs-number\">196.5</span> MB</code></pre><p>&nbsp;</p><p>从网上一个教程中找到以下说法，比我说的好，那就看这个吧！</p><blockquote><p>在列出信息中，可以看到几个字段信息:</p><ul><li>来自于哪个仓库，比如 ubuntu</li><li>镜像的标记，比如 16.04</li><li>它的 ID 号(唯一)，比如e4415b714b62</li><li>创建时间</li><li>镜像大小</li></ul><p>其中镜像的 ID 唯一标识了镜像，注意到 ubuntu:16.04 和 ubuntu:latest具有相同的镜像 ID ，说明它们实际上是同一镜像。 TAG 信息用来标记来自同一个仓库的不同镜像。例如 ubuntu 仓库中有多个镜像，通过 TAG 信息来区分发行版本，例如10.04 、 12.04 、 12.10 、 13.04 、 14.04 等。例如可以使用<code>docker run -t -i ubuntu:16.04 /bin/bash</code>命令指定使用镜像<code>ubuntu:16.04</code>来启动一个容器。如果不指定具体的标记，则默认使用<code>latest</code>标记信息。</p></blockquote><h4></h4><p id=\"启动你的镜像并尽情安装软件吧\"><strong><span>+ 启动你的镜像并尽情安装软件吧！</span></strong></p><p>以下内容均以我自己pull下来的chug的初始镜像为例：</p><p>现在你已经有一个初始的镜像了，注意这个里面是什么都没有的，连vim都没装，是精简到不能再精简的镜像了。</p><p>首先启动它：</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">～<span class=\"hljs-variable\">$ </span>docker run -it chug/ubuntu14.<span class=\"hljs-number\">04</span>x64 /bin/bash\r\nroot<span class=\"hljs-variable\">@aa97ba3292ce</span><span class=\"hljs-symbol\">:/</span><span class=\"hljs-comment\">#</span></code></pre><p><strong><span>-it 表示运行在交互模式，是-i -t的缩写，即-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）一般这个模式就是可以启动bash，然后和容器有命令行的交互</span></strong></p><p>可以看到我们终端的字头变成<code>root@aa97ba3292ce:/#</code>了，这就意味着我们的镜像已经创建了一个容器实例。现在我们可以对这个“ubuntu系统”进行操作了</p><p>&nbsp;</p><p>比如安装vim：</p><pre class=\"prettyprint\"><code class=\"hljs applescript has-numbering\">root@aa97ba3292ce:/<span class=\"hljs-comment\"># <strong><span>apt-get install vim</span></strong></span>\r\nReading package lists... Done\r\nBuilding dependency tree... Done\r\nThe following extra packages will be installed:\r\n  <span class=\"hljs-type\">file</span> libexpat1 libffi6 libgpm2 libmagic1 libpython2<span class=\"hljs-number\">.7</span> libpython2<span class=\"hljs-number\">.7</span>-minimal libpython2<span class=\"hljs-number\">.7</span>-stdlib libsqlite3-<span class=\"hljs-number\">0</span> libssl1<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span> mime-support vim-common vim-runtime\r\nSuggested packages:\r\n  gpm ctags vim-doc vim-scripts\r\nThe following NEW packages will be installed:\r\n  <span class=\"hljs-type\">file</span> libexpat1 libffi6 libgpm2 libmagic1 libpython2<span class=\"hljs-number\">.7</span> libpython2<span class=\"hljs-number\">.7</span>-minimal libpython2<span class=\"hljs-number\">.7</span>-stdlib libsqlite3-<span class=\"hljs-number\">0</span> libssl1<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span> mime-support vim vim-common vim-runtime\r\n<span class=\"hljs-number\">0</span> upgraded, <span class=\"hljs-number\">14</span> newly installed, <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">to</span> remove <span class=\"hljs-keyword\">and</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">not</span> upgraded.\r\nNeed <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">get</span> <span class=\"hljs-number\">10.7</span> MB <span class=\"hljs-keyword\">of</span> archives.\r\nAfter this operation, <span class=\"hljs-number\">50.7</span> MB <span class=\"hljs-keyword\">of</span> additional disk <span class=\"hljs-constant\">space</span> will be used.\r\nDo you want <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">continue</span>? [Y/n]</code></pre><p>看到我没有用sudo，是因为本来就已经是超级用户（root）状态了。</p><p>同理按照我自己的需求，我安装了gcc和gdb</p><h4></h4><p id=\"想退出容器很简单\"><span><strong>+ 想退出容器？很简单！</strong></span></p><p>如果使用exit，命令退出，则容器的状态处于Exit，而不是后台运行。如果想让容器一直运行，而不是停止，可以使用快捷键&nbsp;<strong><span>ctrl+p ctrl+q</span></strong>&nbsp;退出，此时容器的状态为Up。</p><p>查看当前正在运行的容器：</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">~<span class=\"hljs-variable\">$ </span><strong><span>docker ps</span></strong>\r\n<span class=\"hljs-constant\">CONTAINER</span> <span class=\"hljs-constant\">ID</span>        <span class=\"hljs-constant\">IMAGE</span>                 <span class=\"hljs-constant\">COMMAND</span>             <span class=\"hljs-constant\">CREATED</span>             <span class=\"hljs-constant\">STATUS</span>              <span class=\"hljs-constant\">PORTS</span>               <span class=\"hljs-constant\">NAMES</span>\r\naa97ba3292ce        chug/ubuntu14.<span class=\"hljs-number\">04</span>x64   <span class=\"hljs-string\">\"/bin/bash\"</span>         <span class=\"hljs-number\">7</span> minutes ago       <span class=\"hljs-constant\">Up</span> <span class=\"hljs-number\">7</span> minutes                           relaxed_hoover</code></pre><p>&nbsp;</p><p>看到当前有一个ID为aa97ba3292ce的容器(Copyright ©&nbsp;<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://blog.csdn.net/s_gy_zetrov\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.csdn.net/s_gy_zetrov</a>. All Rights Reserved)</p><p>启动、停止、重启容器aa97ba3292ce的命令：</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">~<span class=\"hljs-variable\">$ </span><strong><span>docker start aa97ba3292ce</span></strong>\r\n~<span class=\"hljs-variable\">$ </span><span><strong>docker stop aa97ba3292ce</strong></span>\r\n~<span class=\"hljs-variable\">$ </span><span><strong>docker restart aa97ba3292ce</strong></span></code></pre><p>&nbsp;</p><p><strong><span>后台启动一个容器后，如果想进入到这个容器，可以使用attach命令</span></strong>：</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">~<span class=\"hljs-variable\">$ </span><strong><span>docker attach aa97ba3292ce</span></strong></code></pre><h4></h4><h4></h4><p id=\"软件装完想保存环境commit帮你\"><span><strong>+ 软件装完，想保存环境？commit帮你！</strong></span></p><p>将容器转化为一个镜像，即执行commit操作，完成后可使用<strong><span><code>docker images</code></span></strong>查看</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">root<span class=\"hljs-variable\">@aa97ba3292ce</span><span class=\"hljs-symbol\">:/</span><span class=\"hljs-comment\">#exit //先退出容器</span>\r\n~<span class=\"hljs-variable\">$ </span><strong><span>docker commit -m <span class=\"hljs-string\">\"ubuntu with vim\"</span> -a <span class=\"hljs-string\">\"sgy\"</span> aa97ba3292ce sgy/<span class=\"hljs-symbol\">ubuntu:</span>vim</span></strong>\r\n~<span class=\"hljs-variable\">$ </span>docker images\r\n<span class=\"hljs-constant\">REPOSITORY</span>                    <span class=\"hljs-constant\">TAG</span>    <span class=\"hljs-constant\">IMAGE</span> <span class=\"hljs-constant\">ID</span>         <span class=\"hljs-constant\">CREATED</span>             <span class=\"hljs-constant\">SIZE</span>\r\nsgy/ubuntu                    vim    <span class=\"hljs-number\">52166</span>e4475ed     <span class=\"hljs-number\">5</span> seconds ago       <span class=\"hljs-number\">358.1</span> <span class=\"hljs-constant\">MB</span>\r\nchug/ubuntu14.<span class=\"hljs-number\">04</span>x64           latest <span class=\"hljs-number\">05</span>84b3d2cf6d     <span class=\"hljs-number\">9</span> days ago          <span class=\"hljs-number\">196.5</span> <span class=\"hljs-constant\">MB</span></code></pre><p>&nbsp;</p><p>其中，-m指定说明信息；-a指定用户信息；aa97ba3292ce代表容器的id；sgy/ubuntu:vim指定目标镜像的用户名、仓库名和 tag 信息。我这里都是为了博客瞎编的用户名，我自己的用户名也不是sgy，你运行命令的时候使用自己注册Docker时的用户名。</p><p>此时Docker中就有了我们新建的镜像sgy/ubuntu:vim，此镜像和原有的ubuntu镜像区别在于多了个vim工具。此时我们利用新镜像创建的容器，本身就自带vim了。</p><p>启动新创建的镜像，可以看到vim已经自带了。</p><pre class=\"prettyprint\"><code class=\"hljs r has-numbering\">~$ <strong><span>docker run -it sgy/ubuntu:vim /bin/bash</span></strong>\r\nroot@520afc596c51:/<span class=\"hljs-comment\"># vim --version</span>\r\nVIM - Vi IMproved <span class=\"hljs-number\">7.4</span> (<span class=\"hljs-number\">2013</span> Aug <span class=\"hljs-number\">10</span>, compiled Apr  <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2017</span> <span class=\"hljs-number\">18</span>:<span class=\"hljs-number\">14</span>:<span class=\"hljs-number\">54</span>)\r\n<span class=\"hljs-keyword\">...</span>\r\n//omitted by sgy(Copyright © http://blog.csdn.net/s_gy_zetrov. All Rights Reserved)\r\n<span class=\"hljs-keyword\">...</span></code></pre><p>利用exit退出容器。此时Docker引擎中就有了两个容器，可使用<code>docker ps -a</code>查看。</p><h4></h4><h4>+ 想要删除容器或者镜像？用这个！</h4><p>如果想删除容器或者镜像，可以使用rm命令，注意：<span><strong>删除镜像前必须先删除以此镜像为基础的容器（哪怕是已经停止的容器），否则无法删除该镜像，会报错<code>Failed to remove image (e4415b714b62): Error response from daemon: conflict: unable to delete e4415b714b62 (cannot be forced) - image has dependent child images</code>类似这种</strong></span>。</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">~<span class=\"hljs-variable\">$ </span><strong><span>docker rm container_id</span></strong>\r\n~<span class=\"hljs-variable\">$ </span><span><strong>docker rmi image_id</strong></span></code></pre><p>&nbsp;</p><p>有的时候尽管删除了全部容器，镜像还是无法删除，这时点击mac顶栏中的docker logo，选择restart，然后再试一次rmi，应该就没问题了。(Copyright ©&nbsp;<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://blog.csdn.net/s_gy_zetrov\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.csdn.net/s_gy_zetrov</a>. All Rights Reserved)</p><h4 id=\"附上一张高大上的docker命令图\">+ 附上一张高大上的Docker命令图</h4><p><img title=\"\" data-original=\"https://img-blog.csdn.net/20171005132826220\" src=\"https://media.liuyanzhao.com/wp-content/themes/begin/img/blank.gif\" alt=\"docker4.png\"></p><h4></h4><p id=\"一次配置到处使用那就push到hub上吧\"><span><strong>+ 一次配置，到处使用？那就push到hub上吧！</strong></span></p><p>因为之前已经在Docker.app中登陆了Docker账号，所以现在直接</p><pre class=\"prettyprint\"><code class=\"hljs ruby has-numbering\">~<span class=\"hljs-variable\">$ </span><strong><span>docker push sgy/<span class=\"hljs-symbol\">ubuntu:</span>vim</span></strong></code></pre><p>就可以了！</p><p>下次到了机房，在ubuntu系统中安装Docker，配置好加速器，启动Docker，<strong><span><code>docker login</code></span></strong>登陆自己的账号，然后直接<code>~$&nbsp;<span><strong>docker pull sgy/ubuntu:vim</strong></span></code>就可以把你push到hub的已经配置好的环境的镜像给扒下来。做完实验，再push上去就ok了！</p><h2></h2><h2>Docker中安装gcc、gdb时遇到的问题</h2><p id=\"add-apt-repository-command-not-found\"><span><strong>+ add-apt-repository: command not found</strong></span></p><p>14.04系统解决办法：</p><pre class=\"prettyprint\"><code class=\"hljs lasso has-numbering\">apt<span class=\"hljs-attribute\">-get</span> install software<span class=\"hljs-attribute\">-properties</span><span class=\"hljs-attribute\">-common</span></code></pre><p>&nbsp;</p><p>older版本的系统：</p><pre class=\"prettyprint\"><code class=\"hljs lasso has-numbering\">apt<span class=\"hljs-attribute\">-get</span> install python<span class=\"hljs-attribute\">-software</span><span class=\"hljs-attribute\">-properties</span></code></pre><h4></h4><p id=\"docker中使用gdb无法进入断点无法调试\"><strong><span>+ Docker中使用gdb无法进入断点，无法调试</span></strong></p><p>加上<code>--privileged</code>参数</p><pre class=\"prettyprint\"><code class=\"hljs applescript has-numbering\">～$ docker <span class=\"hljs-command\">run</span> -<span class=\"hljs-keyword\">it</span> <span class=\"hljs-comment\">--privileged sgy/ubuntu:vim /bin/bash</span></code></pre>","articleSummary":"原文地址：https://blog.csdn.net/S_gy_Zetrov/article/details/78161154写在前面这篇博客适合谁？对于Docker并不了解，只是有一点模糊的感觉，觉得Docker可以当成虚拟机用之类的只是下载了Docker软件，对于怎么配置，怎么玩，第一步干什么，","articleThumbnail":"/img/thumbnail/random/img_2.jpg","user":null,"tagList":null,"categoryList":null},{"articleId":2,"articleUserId":2,"articleTitle":"springmvc 表单中文乱码解决方案","articleViewCount":16,"articleCommentCount":2,"articleLikeCount":1,"articleCreateTime":1507378362000,"articleUpdateTime":1543179133000,"articleIsComment":1,"articleStatus":1,"articleOrder":1,"articleContent":"<p>基本上通过在 web.xml 了配置拦截器就可以解决。</p><p>这里需要注意的是，最好把这段代码放在web.xml中开头的位置，因为拦截有顺序，如果放在后面的话容易拦截不到。</p><p>拦截器代码如下</p><p></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-xml\"><li class=\"alt\"><span><span class=\"comments\"><!--post乱码过滤器--></span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"comments\"><!-- 配置springMVC编码过滤器 --></span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"tag\">&lt;</span><span class=\"tag-name\">filter</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>CharacterEncodingFilter</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-class</span><span class=\"tag\">&gt;</span><span>org.springframework.web.filter.CharacterEncodingFilter</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">filter-class</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!-- 设置过滤器中的属性值 --></span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>encoding</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>UTF-8</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!-- 启动过滤器 --></span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>forceEncoding</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>true</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"\"><span><span class=\"tag\"><!--</span--><span class=\"tag-name\">filter</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"alt\"><span><span class=\"comments\"><!-- 过滤所有请求 --></span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-mapping</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>CharacterEncodingFilter</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span><span>/*</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li><li class=\"alt\"><span><span class=\"tag\"><!--</span--><span class=\"tag-name\">filter-mapping</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></span></li></ol></div></div><p><br></p><p>顺便再补充其他的几个可能原因。</p><p></p><p>1、数据库和数据表不是 utf-8 编码</p><p>就在前几天，我遇到的问题正是这个。当时是刚从 windows 搬到 mac。也是在提交 post 表单的时候，中文一直是乱码，后台百度发现，原来是 navicat 的原因。就是在新建 数据库连接(注意是连接)，不能选择 utf-8，应该选择默认的自动。这个地方很坑人。</p><p>数据库和数据表当然是 utf-8，一般这种情况很少出错。</p><p>&nbsp;</p><p>2、修改 Tomcat 的 server.xml 文件，添加 utf-8 编码</p><p></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-j\"><li class=\"alt\"><span><span><connector port=< span=\"\"><span class=\"string\">\"8080\"</span><span>&nbsp;protocol=</span><span class=\"string\">\"HTTP/1.1\"</span><span>&nbsp;&nbsp;</span></connector port=<></span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectionTimeout=<span class=\"string\">\"20000\"</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirectPort=<span class=\"string\">\"8443\"</span><span>&nbsp;URIEncoding=</span><span class=\"string\">\"UTF-8\"</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useBodyEncodingForURI=<span class=\"string\">\"true\"</span><span>&nbsp;/&gt;&nbsp;&nbsp;</span></span></li></ol></div></div><br><p></p><p>3、注意你的 IDE (如Eclipse,IntelliJ IDEA)的 jsp 文件编码，一般在右下角可以看出来，通常我们也要把默认的编码设置为 utf-8。</p><p>&nbsp;</p><p>4、还有一种方法就是 直接对接收到的数据编码转换，我感觉有点麻烦，所以不是很喜欢</p><p></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-j\"><li class=\"alt\"><span><span>String&nbsp;name=</span><span class=\"keyword\">new</span><span>&nbsp;String((user.getUname()).getBytes(</span><span class=\"string\">\"ISO-8859-1\"</span><span>),</span><span class=\"string\">\"utf8\"</span><span>);&nbsp;&nbsp;</span></span></li></ol></div></div><p><span>总结：一般来说，第一种拦截器方法是可用的，要注意的是要把拦截器代码放到 web.xml 头部，防止拦截不到，还有表单一定要 post 方式提交。</span></p><p></p>","articleSummary":null,"articleThumbnail":"/img/thumbnail/random/img_2.jpg","user":null,"tagList":null,"categoryList":null},{"articleId":17,"articleUserId":2,"articleTitle":"java中ImageIcon路径问题","articleViewCount":13,"articleCommentCount":5,"articleLikeCount":0,"articleCreateTime":1507392355000,"articleUpdateTime":1543178787000,"articleIsComment":1,"articleStatus":1,"articleOrder":1,"articleContent":"<h2><strong>一、问题</strong></h2><p>ImageIcon icon = new ImageIcon(\"logo.jpg\");</p><p>执行结果是icon无法显示</p><p>&nbsp;</p><h2><strong>二、解决</strong></h2><p>类中有如下调用：</p><p><span>ImageIcon icon = new ImageIcon(\"1.jpg\");</span></p><p>&nbsp;</p><p>很自然地认为当前类文件和图片在同一路径下即可。</p><p><span><strong>其实所谓的相对路径起点是工程的根目录，即project。</strong></span></p><p>这行代码执行时在project目录下查找名为a.gif的文件，结果当然是找不到。</p><p>要得到工程的相对路径可通过System.getProperty(\"user.dir\")得到。</p><p>对图片和对文件的查找应该是一致的，如new File()。</p><p>&nbsp;</p><p>1、假如你的工程根目录为：Project1</p><p>你的图片文件放在：Project1/src/images/1.jpg</p><p>所以正确的调用是（不要加Project1）：</p><p>ImageIcon icon = new ImageIcon(\"src/images/1.jpg\");</p><p>&nbsp;</p><p>2、假如你的工程根目录为：Project1</p><p>你的图片文件在：Project1/src/com.liuyanzhao/1.jpg</p><p>所以正确的调用是(<strong>com.liuyanzhao</strong>是包名)</p><p>ImageIcon icon = new ImageIcon(\"src/com/liuyanzhao/1.jpg\");</p><p>这行代码执行时在project/test目录下查找到了文件</p><p>&nbsp;</p><p><strong>总结起来就是一句话：所谓相对路径就是相对于工程根目录的位置^_^</strong></p><p>&nbsp;</p><h2>三、其他</h2><p>查看了一下ImageIcon的构造函数。</p><p>Public ImageIcon(String filename)//参数可以是绝对路径也可以是相对路径</p><p>Public ImageIcon(URL url)</p><p>&nbsp;</p><p>第一种构造不在赘述。</p><p>第二种通过URL来得到图片</p><p>URL url = getClass().getResource(\"a.gif\"); //当前编译后class文件所在目录查找</p><p>ImageIcon icon = new ImageIcon(url);</p><p>&nbsp;</p><p>ImageIcon支持GIF、JPG、PNG等格式。</p>","articleSummary":null,"articleThumbnail":"/img/thumbnail/random/img_7.jpg","user":null,"tagList":null,"categoryList":null},{"articleId":4,"articleUserId":1,"articleTitle":"[转载]HTTP的幂等性","articleViewCount":13,"articleCommentCount":0,"articleLikeCount":0,"articleCreateTime":1507390640000,"articleUpdateTime":1543179065000,"articleIsComment":1,"articleStatus":1,"articleOrder":1,"articleContent":"<div id=\"header\"><h2>理解HTTP幂等性</h2></div><div id=\"post_detail\"><div class=\"post\"><div class=\"postText\"><div id=\"cnblogs_post_body\"><p>基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。HTTP协议是一种分布式的面向资源的网络应用层协议，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、<a href=\"https://liuyanzhao.com/tag/java/\" title=\"查看与 Java 相关的文章\" target=\"_blank\">Java</a>script、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的<a href=\"https://liuyanzhao.com/tag/java/\" title=\"查看与 Java 相关的文章\" target=\"_blank\">Java</a>语言并不意味着高质量的<a href=\"https://liuyanzhao.com/tag/java/\" title=\"查看与 Java 相关的文章\" target=\"_blank\">Java</a>程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。</p><h2>幂等性定义</h2><p>本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：</p><blockquote><p>Methods can also have the property of \"idempotence\" in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p></blockquote><p>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p><h2>分布式事务 vs 幂等设计</h2><p>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><pre><code>bool withdraw(account_id, amount)\r\n</code></pre><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：</p><p><img src=\"/uploads/2017/10/20171007153621950.png\" alt=\"20171007153621950.png\"><br></p><p>图1</p><p>这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><pre><code>int create_ticket() \r\nbool idempotent_withdraw(ticket_id, account_id, amount)\r\n</code></pre><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p><img src=\"/uploads/2017/10/20171007153648208.png\" alt=\"20171007153648208.png\"><br></p><div id=\"cnblogs_post_body\"><p>图2</p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h2>HTTP的幂等性</h2><p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p><p>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p><p>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p><blockquote><p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line ...... If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p><p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p></blockquote><p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p><p>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h2>总结</h2><p>上面简单介绍了幂等性的概念，用幂等设计取代分布式事务的方法，以及HTTP主要方法的语义和幂等性特征。其实，如果要追根溯源，幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同，有兴趣的读者可以从Wikipedia上进一步了解。</p><h2>参考</h2><p><a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\">RFC 2616, Hypertext Transfer Protocol -- HTTP/1.1, Method Definitions</a></p><p><a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://devhawk.net/2007/11/09/the-importance-of-idempotence/\">The Importance of Idempotence</a></p><p><a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://stackoverflow.com/questions/630453/put-vs-post-in-rest\">Stackoverflow - PUT vs POST in REST</a></p></div><p>&nbsp;</p><p>&nbsp;</p><p>原文地址：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html</a></p></div></div></div></div>","articleSummary":null,"articleThumbnail":"/img/thumbnail/random/img_4.jpg","user":null,"tagList":null,"categoryList":null}]}